/**
 * 数据格式生成器
 * @param { Array } data 传入一个数组
 * @returns { Array | Boolean } 返回一个具有特定格式的数组 | 失败返回false
 */
 function formatTabs(data) {
  let result = true
  let cols = data[0].split(',').length
  const tabs = []

  // 遍历每一行 检查是否对称
  data.forEach((row) => {
    row = row.split(',')
    if (row.length !== cols) result = false
  })
  if (result === false) return false

  // 依据 maxCols 生成模板
  for (let i = 0; i < cols; i++) {
    tabs.push({
      len: 0,
      tabs: 0
    })
  }

  return tabs
}

/**
 * 制表符生成
 * @param { Number } num 指定数量
 * @returns { String } 返回指定数量的制表符
 */
function genTabs(num) {
  let str = ''
  for (let i = 0; i < num; i++) {
    str += '\t'
  }

  return str
}

/**
 * 制表符占用数量计算
 * @param { String } str 要计算的字符串
 * @returns { Number } 占多少个制表符
 */
function calcTabs(str) {
  /*
    1个tab = 7个英文或数字 = 3.5个中文
    字符[1] = tab[0.125]
    中文[1] = tab[0.25]
  */
  const chinese = /[\u4e00-\u9fa5]/g // 匹配汉字
  const char = /[`A-Za-z0-9~!@#$%\^&\*\?\(\)_\+-=\[\]\{\};:'"<>,\.\|\/\\ ]/g // 匹配字符
  const chineseNum = str.match(chinese) ? str.match(chinese).length : 0 // 匹配不到则等于0
  const charNum = str.match(char) ? str.match(char).length : 0 // 匹配不到则等于0
  const result = Math.ceil((chineseNum * 250 + charNum * 125) / 1000) // 向上取整

  // 内容刚好为一个tab时，应额外加一个tab。
  if (result === 1) return 2
  else return result
}

/**
 * 防止内容小于一个tab的长度时tab自动补全为一个tab
 * @param { String } str 给定一个字符串
 * @returns { String } 返回长度为8的字符串
 */
function fillSpace(str) {
  str = String(str) // 强制转换为字符串类型
  const chinese = /[\u4e00-\u9fa5]/g // 正则 - 匹配汉字
  const char = /[`A-Za-z0-9~!@#$%\^&\*\?\(\)_\+-=\[\]\{\};:'"<>,\.\|\/\\ ]/g // 正则 - 匹配字符
  const chineseNum = str.match(chinese) ? str.match(chinese).length : 0
  const charNum = str.match(char) ? str.match(char).length : 0
  // 获取长度（1个汉字 = 2，1个字母 = 1）
  let len = charNum + chineseNum * 2
  // 长度小于 8 时, 向后添加空格，使其长度刚好等于 8
  if (str.length < 8) {
    for (let i = 0; i < 8 - len; i++) {
      str += ' '
    }
  }

  return str
}

module.exports = (arr) => {
  /**
   * 此数组长度自适应传入数据的列数
   * 此对象用于存储每一列最长的最大长度和最大长度所占tab数量
   * 数据结构：
   * tabs = [
   *   col: {
   *     len: 0, // 字符长度
   *     tabs: 0 // 占用tab
   *   }
   * ]
   */
  const tabs = formatTabs(arr)
  if (tabs === false) return console.log('数据校验失败')

  /**
   * 根据传入的 arr 初始化 tabs 数组, 遍历每一行找到 [最大长度] 并计算其 [占用的 tab 数量]
   * 此步骤的计算结果将保存至 tabs 数组内
   */
  arr.forEach((row) => {
    row = row.split(',')
    // 遍历每一列
    for (let i = 0, len = row.length; i < len; i++) {
      if (String(row[i]).length > tabs[i].len) {
        tabs[i].len = String(row[i]).length
        tabs[i].tabs = calcTabs(String(row[i])) + 1
      }
    }
  })

  /**
   * 最终的数据
   */
  let data = ''

  /**
   * 生成最终数据
   */
  arr.forEach((row) => {
    row = row.split(',')
    // 每一列间隔的 tabs 数量
    const colTabs = []

    // 计算每一列间隔的 tabs 数量
    for (let i = 0, iLen = row.length; i < iLen; i++) {
      colTabs.push(tabs[i].tabs - calcTabs(row[i]))
    }

    // 根据每一列间隔的 tabs 数量, 将指定数量的 tabs 添加到 data 内
    for (let j = 0, jLen = row.length; j < jLen; j++) {
      data += fillSpace(row[j]) + genTabs(colTabs[j])
    }

    // 行末的换行符
    data += '\n'
  })

  console.log(data)
}
